# 阅读笔记

## 第一章

第一章用一个对磁盘文件进行归并排序的问题进行切入，并且严格限制了内存使用的大小和程序运行的时间。

如果默认我们需要对一个32位的整数进行排序，那么多路归并排序就成为了唯一的选择。

事实上，如果对问题的实际应用场景进行分析，我们也许会得到一些能够简化问题的信息，在这一章中的一个好消息是每个数字都小于一千万，而且不会重复，这样首先想到可以用更少的位去表示这些数字。但是即便用7个字节存储每一个数，仍然不能将这些数据一次性在内存中装下，但是按位存给了我们一个提示，就是用位去表征一个数。那么久自然想到用一个位表示一个数。将可用的1MB的内存转化为一个有800多万个可用位的位向量，从左往右分别代表0,1,2...，但是800万个可用位显然存不下1000万个数，所以看上去一趟算法并不能实现将1000万个数完全排序。

因此我们需要想一想1000万个数据如何高效的存储，根据信息论的知识，如果单纯的把一个数用1bit来存，1MB的空间显然是不够的，这种情况就在问题5中进行了思考。

最后在“简单的设计”里面有一句话说的很好“设计者确定其设计已经达到了完美的标准不是不能在增加任何东西，而是不能再减少任何东西...简单的程序通常比具有相同的功能的复杂程序更可靠、更健壮、更高效。而且易于实现和维护”。想起《吕氏春秋》的“一字千金”，都是将要表达的信息用尽可能少的可见载体呈现。

## 第二章

第二章开篇提出了三个问题

* 给定一个最多包含40亿个随机排列的21位整数，找出一个不在文件中的32位整数
  * 在足够的内存情况下，如何解决该问题
  * 内存很少，但是有几个外部的“临时”文件可用，如何解决该问题
* 将一个n元向量向左旋转i个位置。例如，当n=8，i=3时，向量abcdefgh旋转为defghabc。如何使用数十个额外字节的存储空间，在正比于n的时间完成向量的旋转
* 给定一个英语词典，找出其中的所有变位词的结合。例如"pots","stops","tops"互为变位词

### 问题1

(1) 在内存足够的情况下，可以使用位向量的方法表征每一个出现的数，至少需要512Mb的内存空间存储时间复杂度是O(n)

(2) 内存不足的情况

内存不足的情况下，对于输入的数据，先根据最高位按照0和1进行划分，写到两个文件中，文件名是“0”和“1”，然后看这两个文件中的数是否是2^32个，如果有一个不满，说明有缺的数，那么把这个文件的数作为输入进行"0/1"探测，一直这样进行下去，知道发现“0/1”探测的结果中有一个文件为空，说明当前位没有数据，这样就能找到不存在的数

<center>![](../img/charpter2-Q1.png)</center>

### 问题2

这个问题关键要找到技巧，先分析一下问题，相当于有两个相邻的块，现在要交换它们的位置。一个最简单的方法是开辟一个新的空间，将其中的一块暂存起来，之后把第二块往前移，最后把暂存起来的第一块放到相应的位置上去。

如果块很大而可用的空间很少，就需要一些精巧的方法，一种巧妙的实现是通过三次翻转完成的

```Java
public static void swap(char[] str, int from, int to){
  for(int i = from,j = to; i < j; i++,j--){
    char tmp = str[i];
    str[i] = str[j];
    str[j] = tmp;
  }
}

public static void main(String[] args){
  char[] str = {'a','b','c','d','e','f','g','h'};
  swap(str, 0, 2);
  swap(str, 3, 7);
  swap(str, 0, 7);
  System.out.println(str[1]);
}
```




## 第三章
